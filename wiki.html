<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>StreamBoard - Documentação Técnica</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Fira+Code:wght@400;500&display=swap");

      :root {
        --font-family-base: "Inter", sans-serif;
        --font-family-code: "Fira Code", monospace;
        --color-primary: #00c86f;
        --color-primary-light: #e6f9f1;
        --color-text: #2c3e50;
        --color-muted: #7f8c8d;
        --color-background: #f8f9fa;
        --color-surface: #ffffff;
        --color-border: #e9ecef;
        --color-code-bg: #2d3748;
        --radius: 8px;
      }

      html {
        scroll-behavior: smooth;
        scroll-padding-top: 2rem;
      }

      body {
        font-family: var(--font-family-base);
        background-color: var(--color-background);
        color: var(--color-text);
        margin: 0;
        display: flex;
        line-height: 1.7;
      }

      nav.sidebar {
        width: 280px;
        background-color: var(--color-surface);
        border-right: 1px solid var(--color-border);
        padding: 2rem 0;
        height: 100vh;
        position: sticky;
        top: 0;
        flex-shrink: 0;
        overflow-y: auto;
      }

      .sidebar-header {
        padding: 0 1.5rem 1.5rem 1.5rem;
        text-align: center;
        border-bottom: 1px solid var(--color-border);
      }

      .sidebar-header img {
        max-width: 150px;
        margin-bottom: 0.5rem;
      }

      .sidebar-header h1 {
        font-size: 1.5rem;
        margin: 0;
        color: var(--color-text);
      }

      .sidebar-header .version {
        font-size: 0.8rem;
        font-weight: normal;
        background-color: var(--color-primary);
        color: white;
        padding: 2px 8px;
        border-radius: 4px;
        vertical-align: middle;
        margin-left: 8px;
      }

      .sidebar ul {
        list-style: none;
        padding: 1rem 0;
        margin: 0;
      }

      .sidebar ul li .nav-header {
        font-size: 0.75rem;
        font-weight: 600;
        color: var(--color-muted);
        text-transform: uppercase;
        padding: 1rem 1.5rem 0.5rem 1.5rem;
        letter-spacing: 0.5px;
      }

      .sidebar ul li a {
        display: block;
        padding: 0.75rem 1.5rem 0.75rem 2.5rem;
        color: var(--color-text);
        text-decoration: none;
        transition: all 0.2s ease;
        border-left: 4px solid transparent;
        font-size: 0.95rem;
      }

      .sidebar ul li a:hover {
        background-color: #f3f4f6;
        color: var(--color-primary);
      }

      .sidebar ul li a.active {
        color: var(--color-primary);
        font-weight: 600;
        border-left-color: var(--color-primary);
        background-color: var(--color-primary-light);
      }

      main {
        flex-grow: 1;
        padding: 2rem 4rem;
        max-width: 900px;
      }

      section {
        padding-top: 2rem;
        margin-bottom: 2rem;
      }

      h2 {
        font-size: 2.5rem;
        color: var(--color-text);
        border-bottom: 3px solid var(--color-primary);
        padding-bottom: 0.5rem;
        margin-bottom: 1.5rem;
      }

      h3 {
        font-size: 1.75rem;
        color: var(--color-text);
        margin-top: 2.5rem;
        margin-bottom: 1.25rem;
      }

      h4 {
        font-size: 1.25rem;
        color: var(--color-text);
        margin-top: 2rem;
        margin-bottom: 1rem;
        border-left: 3px solid var(--color-primary);
        padding-left: 1rem;
      }

      p,
      li {
        font-size: 1rem;
        color: #4b5563;
      }

      ul,
      ol {
        padding-left: 20px;
      }

      li {
        margin-bottom: 0.5rem;
      }

      code {
        background-color: var(--color-primary-light);
        border: 1px solid #bde9d7;
        padding: 2px 6px;
        border-radius: 4px;
        font-family: var(--font-family-code);
        color: #047857;
        font-size: 0.9em;
      }

      pre {
        background-color: var(--color-code-bg);
        color: #e2e8f0;
        border-radius: var(--radius);
        padding: 1.25rem;
        overflow-x: auto;
        white-space: pre;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      pre code {
        border: none;
        padding: 0;
        background-color: transparent;
        color: inherit;
        font-size: 0.9rem;
      }

      a {
        color: var(--color-primary);
        font-weight: 500;
        text-decoration: none;
      }
      a:hover {
        text-decoration: underline;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 1.5rem;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        border: 1px solid var(--color-border);
        border-radius: var(--radius);
        overflow: hidden;
      }

      th,
      td {
        padding: 0.8rem 1rem;
        text-align: left;
        border-bottom: 1px solid var(--color-border);
      }

      tr:last-child td {
        border-bottom: none;
      }

      th {
        background-color: var(--color-background);
        font-size: 0.8rem;
        text-transform: uppercase;
        font-weight: 600;
        color: var(--color-muted);
      }

      .tag {
        display: inline-block;
        padding: 0.25em 0.6em;
        font-size: 0.75em;
        font-weight: 700;
        line-height: 1;
        text-align: center;
        white-space: nowrap;
        vertical-align: baseline;
        border-radius: 0.25rem;
      }
      .tag-get {
        background-color: #e6f9f1;
        color: #047857;
      }
      .tag-post {
        background-color: #eef2ff;
        color: #4338ca;
      }
      .tag-delete {
        background-color: #fee2e2;
        color: #b91c1c;
      }
    </style>
  </head>
  <body>
    <nav class="sidebar">
      <div class="sidebar-header">
        <img src="public/assets/logo.png" alt="StreamBoard Logo" />
        <h1>StreamBoard <span class="version">v1.1</span></h1>
      </div>
      <ul>
        <li><a href="#visao-geral" class="active">Visão Geral</a></li>
        <li><a href="#tecnologias">Pilha de Tecnologias</a></li>
        <li><a href="#ambiente">Configuração do Ambiente</a></li>

        <li><div class="nav-header">Arquitetura</div></li>
        <li><a href="#arquitetura-backend">Backend</a></li>
        <li><a href="#arquitetura-frontend">Frontend</a></li>
        <li><a href="#arquitetura-docker">Conteinerização (Docker)</a></li>

        <li><div class="nav-header">Lógicas Principais</div></li>
        <li><a href="#logica-pareamento">Pareamento de Dispositivo</a></li>
        <li><a href="#logica-campanhas">Exibição de Campanhas</a></li>
        <li><a href="#logica-produtos">Sincronização de Produtos</a></li>
        <li><a href="#logica-websockets">Comunicação Real-Time</a></li>

        <li><div class="nav-header">Detalhes do Backend</div></li>
        <li><a href="#backend-rotas">Rotas (Endpoints)</a></li>
        <li><a href="#backend-servicos">Serviços (Business Logic)</a></li>
      </ul>
    </nav>

    <main>
      <section id="visao-geral">
        <h2>Visão Geral</h2>
        <p>
          O <strong>StreamBoard</strong> é um sistema de gerenciamento de
          conteúdo para sinalização digital (Digital Signage). Ele foi projetado
          para permitir que administradores controlem remotamente o conteúdo
          exibido em múltiplas telas, que podem ser de diferentes tipos, como
          Mídia Indoor, Terminais de Consulta de Preços e Menus Digitais.
        </p>
        <p>
          A plataforma é centralizada em um painel de controle web onde é
          possível gerenciar entidades como Empresas, Setores e Dispositivos. O
          núcleo do sistema é a capacidade de criar, agendar e segmentar
          campanhas de mídia (imagens e vídeos) para dispositivos específicos,
          garantindo que o conteúdo certo seja exibido no lugar e na hora certa.
        </p>
      </section>

      <section id="tecnologias">
        <h2>Pilha de Tecnologias</h2>
        <p>
          A aplicação é construída sobre um conjunto de tecnologias modernas e
          robustas, escolhidas para garantir performance, escalabilidade e
          manutenibilidade.
        </p>
        <table>
          <thead>
            <tr>
              <th>Tecnologia</th>
              <th>Propósito no Projeto</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Node.js / Express.js</strong></td>
              <td>
                Plataforma e framework para a construção do servidor web e da
                API REST. Oferece alta performance para operações de I/O, ideal
                para uma aplicação com muitas conexões simultâneas
                (dispositivos).
              </td>
            </tr>
            <tr>
              <td><strong>PostgreSQL</strong></td>
              <td>
                Banco de dados relacional principal. Armazena todos os dados
                persistentes da aplicação, como usuários, empresas,
                dispositivos, campanhas e produtos. Escolhido por sua robustez,
                confiabilidade e suporte a transações complexas.
              </td>
            </tr>
            <tr>
              <td><strong>Redis</strong></td>
              <td>
                Banco de dados em memória de alta velocidade. No StreamBoard,
                seu papel principal é servir como um message broker para a fila
                de processamento em segundo plano (BullMQ). Ele gerencia os jobs
                que precisam ser executados de forma assíncrona.
              </td>
            </tr>
            <tr>
              <td><strong>BullMQ</strong></td>
              <td>
                Sistema de filas robusto construído sobre o Redis. É utilizado
                para gerenciar tarefas demoradas, como a sincronização de
                produtos com sistemas externos (ERP Sysmo). Isso evita que a API
                principal fique bloqueada, mantendo a interface administrativa
                responsiva.
              </td>
            </tr>
            <tr>
              <td><strong>WebSockets (ws)</strong></td>
              <td>
                Protocolo de comunicação bidirecional em tempo real. Essencial
                para a comunicação instantânea entre o servidor, o painel de
                administração e os dispositivos (players), permitindo
                atualizações de status, envio de comandos remotos e notificações
                de novas campanhas sem a necessidade de recarregar a página.
              </td>
            </tr>
            <tr>
              <td><strong>EJS (Embedded JavaScript)</strong></td>
              <td>
                Motor de templates para renderizar as páginas HTML no lado do
                servidor. Permite injetar dados dinâmicos do backend diretamente
                no HTML enviado ao cliente.
              </td>
            </tr>
            <tr>
              <td><strong>Docker & Docker Compose</strong></td>
              <td>
                Plataforma de conteinerização. Usada para empacotar a aplicação
                e suas dependências (Node.js, PostgreSQL, Redis) em contêineres
                isolados, garantindo um ambiente de desenvolvimento e produção
                consistente e simplificado.
              </td>
            </tr>
          </tbody>
        </table>
      </section>

      <section id="ambiente">
        <h2>Configuração do Ambiente</h2>
        <p>
          Para executar o projeto localmente, a forma mais recomendada é
          utilizando Docker, que provisiona todo o ambiente necessário.
        </p>

        <h4>1. Arquivo de Ambiente (<code>.env</code>)</h4>
        <p>
          Primeiro, crie um arquivo chamado <code>.env</code> na raiz do
          projeto, copiando o conteúdo do arquivo <code>.env.example</code> (se
          existir) ou usando a estrutura abaixo. Este arquivo armazena as
          credenciais e configurações sensíveis.
        </p>
        <pre><code># Configurações do Banco de Dados Principal (StreamBoard)
DB_USER=admin
DB_PASSWORD=sua_senha_segura
DB_HOST=database
DB_PORT=5432
DB_NAME=streamboard

# Segredos da Aplicação
SESSION_SECRET=segredo_para_sessoes_web
JWT_SECRET=segredo_para_tokens_dos_dispositivos

# Conexão com Banco de Dados Externo (Sysmo ERP)
PG_HOST=ip_do_servidor_sysmo
PG_PORT=5432
PG_USER=usuario_sysmo
PG_PASSWORD=senha_sysmo
PG_DATABASE=dados

# Credenciais para APIs Externas
CAMPEAO_API_EMAIL=email@exemplo.com
CAMPEAO_API_PASSWORD=senha_api
OPENWEATHER_API_KEY=sua_chave_api_openweathermap

# Configuração do Redis (para Jobs)
REDIS_HOST=redis
REDIS_PORT=6379</code></pre>

        <h4>2. Subindo os Contêineres</h4>
        <p>
          Com o Docker e o Docker Compose instalados, execute o seguinte comando
          na raiz do projeto:
        </p>
        <pre><code>docker-compose up --build</code></pre>
        <p>Este comando irá:</p>
        <ul>
          <li>
            Construir a imagem Docker da aplicação Node.js (<code
              >application</code
            >
            e <code>worker</code>).
          </li>
          <li>
            Baixar e iniciar os contêineres do PostgreSQL
            (<code>database</code>) e Redis (<code>redis</code>).
          </li>
          <li>Conectar todos os serviços na mesma rede virtual.</li>
        </ul>

        <h4>3. Configurando o Banco de Dados</h4>
        <p>
          Após os contêineres estarem rodando, o banco de dados estará vazio.
          Para criar as tabelas e a estrutura necessária, execute o script de
          setup em um novo terminal:
        </p>
        <pre><code>docker-compose exec application node utils/setup.js</code></pre>
        <p>
          <strong>Atenção:</strong> Este comando irá apagar e recriar o banco de
          dados <code>streamboard</code>, se ele já existir.
        </p>

        <h4>4. Criando um Usuário Administrador</h4>
        <p>
          O sistema não possui uma tela de registro. Para acessar o painel, você
          precisa criar um usuário manualmente através do script interativo:
        </p>
        <pre><code>docker-compose exec application node utils/usercreate.js</code></pre>
        <p>
          Siga as instruções no terminal para definir o nome de usuário, email,
          senha e definir o papel (role) como <code>admin</code>.
        </p>

        <h4>5. Acessando a Aplicação</h4>
        <p>
          A aplicação estará disponível em
          <a href="http://localhost:3000" target="_blank"
            >http://localhost:3000</a
          >. Use as credenciais criadas no passo anterior para fazer login.
        </p>
      </section>

      <section id="arquitetura-backend">
        <h2>Arquitetura do Backend</h2>
        <p>
          O backend segue uma arquitetura em camadas (conhecida como "Monolito
          Modular") para separar as responsabilidades e facilitar a manutenção.
          O fluxo de uma requisição HTTP geralmente passa pelas camadas de
          <strong>Rotas</strong>, <strong>Middlewares</strong>,
          <strong>Controladores</strong> e <strong>Serviços</strong>.
        </p>
        <pre><code>/
├── config/             # Conexões com bancos de dados (streamboard.js, sysmo.js)
├── src/
│   ├── controllers/    # Lógica de requisição e resposta (HTTP)
│   ├── jobs/           # Configuração da fila (BullMQ) e do worker
│   ├── middlewares/    # Funções intermediárias (ex: autenticação)
│   ├── routes/         # Definição dos endpoints da API
│   ├── services/       # Lógica de negócio e acesso aos dados
│   ├── utils/          # Funções utilitárias (logger, formatadores)
│   └── websocket/      # Gerenciador da conexão WebSocket
└── server.js           # Ponto de entrada da aplicação</code></pre>
      </section>

      <section id="arquitetura-frontend">
        <h2>Arquitetura do Frontend</h2>
        <p>
          O frontend é renderizado no servidor usando EJS e a interatividade é
          adicionada com JavaScript modular no lado do cliente.
        </p>
        <pre><code>/
├── public/
│   ├── css/            # Arquivos de estilo (styles.css, menu.css)
│   ├── js/
│   │   ├── admin/      # Módulos JS para o painel de administração
│   │   ├── player/     # Módulos JS para as telas dos dispositivos
│   │   └── utils/      # Utilitários compartilhados (ex: connector.js)
│   └── main.js         # Ponto de entrada que carrega os módulos do admin
└── views/
    ├── partials/       # Componentes reutilizáveis (navbar.ejs, footer.ejs)
    └── *.ejs           # Arquivos de template para cada página</code></pre>
      </section>

      <section id="arquitetura-docker">
        <h2>Conteinerização (Docker)</h2>
        <p>
          O `docker-compose.yml` orquestra os quatro serviços principais da
          aplicação.
        </p>
        <ul>
          <li>
            <strong>application:</strong> O serviço principal da aplicação
            Node.js. Ele executa o `server.js`, expondo a porta 3000 e se
            conectando aos outros serviços.
          </li>
          <li>
            <strong>worker:</strong> Uma instância separada da aplicação Node.js
            que executa apenas o script `src/jobs/worker.js`. Sua única
            responsabilidade é processar os jobs da fila do BullMQ, garantindo
            que tarefas pesadas não travem a aplicação principal.
          </li>
          <li>
            <strong>database:</strong> O contêiner do PostgreSQL, que persiste
            os dados em um volume Docker para que não sejam perdidos ao
            reiniciar.
          </li>
          <li>
            <strong>redis:</strong> O contêiner do Redis, que atua como
            intermediário para a fila de jobs.
          </li>
        </ul>
      </section>

      <section id="logica-pareamento">
        <h2>Fluxo: Pareamento de Dispositivo</h2>
        <p>
          O pareamento é o processo que vincula um dispositivo físico (player) a
          um registro no sistema, garantindo sua autenticidade e autorização
          para receber conteúdo.
        </p>
        <ol>
          <li>
            <strong>Admin Gera Credencial:</strong> No painel, o administrador
            clica em um dispositivo "Inativo" e gera um
            <strong>OTP</strong> (código numérico de 6 dígitos, válido por 5
            minutos) ou um <strong>Magic Link</strong> (URL única).
          </li>
          <li>
            <strong>Armazenamento Seguro:</strong> O OTP ou o token do Magic
            Link é hasheado (usando bcrypt ou SHA256) e armazenado no banco de
            dados, associado ao ID do dispositivo.
          </li>
          <li>
            <strong>Dispositivo Envia Credencial:</strong> A pessoa no local do
            dispositivo acessa a página de pareamento (`/pair`) e insere o OTP
            ou acessa o Magic Link.
          </li>
          <li>
            <strong>Validação no Backend:</strong> O `pairing.service.js` recebe
            a credencial, busca o hash correspondente no banco, verifica se não
            expirou ou já foi usado, e compara com a credencial enviada.
          </li>
          <li>
            <strong>Geração de Tokens:</strong> Se a validação for bem-sucedida,
            o `token.service.js` gera um par de tokens
            <strong>JWT (JSON Web Token)</strong>: um <em>Access Token</em> de
            curta duração (15 min) e um <em>Refresh Token</em> de longa duração
            (90 dias).
          </li>
          <li>
            <strong>Armazenamento e Resposta:</strong> Os novos tokens são
            armazenados no banco de dados e enviados ao dispositivo através de
            cookies HTTP-Only, que são seguros. O dispositivo é redirecionado
            para a tela correta (`/player`, `/price` ou `/menu`).
          </li>
        </ol>
      </section>

      <section id="logica-campanhas">
        <h2>Fluxo: Exibição de Campanhas</h2>
        <p>
          Este é o fluxo principal para um dispositivo já pareado exibir o
          conteúdo correto.
        </p>
        <ol>
          <li>
            <strong>Autenticação:</strong> O dispositivo faz uma requisição para
            uma rota protegida (ex: `/api/device/playlist`). O middleware
            `deviceAuth` intercepta a requisição, verifica o Access Token no
            cookie. Se estiver expirado, ele usa o Refresh Token para gerar um
            novo par de tokens, garantindo a sessão contínua.
          </li>
          <li>
            <strong>Lógica de Seleção de Playlist:</strong> A função
            `deviceService.getDevicePlaylist` é chamada. Ela executa uma query
            complexa no PostgreSQL que seleciona a campanha correta baseada em
            uma hierarquia de regras:
            <ul>
              <li>
                A campanha deve pertencer à mesma <strong>empresa</strong> do
                dispositivo.
              </li>
              <li>
                A data e hora atuais devem estar entre a
                <strong>data de início e fim</strong> da campanha.
              </li>
              <li>
                A campanha deve corresponder à <strong>segmentação</strong>:
                <ul>
                  <li>
                    Se a campanha tem dispositivos específicos como alvo, o ID
                    do dispositivo atual deve estar na lista.
                  </li>
                  <li>
                    Senão, se a campanha tem setores como alvo, o setor do
                    dispositivo atual deve estar na lista.
                  </li>
                  <li>
                    Se a campanha não tem segmentação específica, ela se aplica
                    a todos os dispositivos da empresa.
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            <strong>Montagem da Resposta:</strong> O serviço monta um objeto
            JSON contendo os arquivos de mídia da campanha selecionada, o tipo
            de layout, e dados adicionais como informações de clima, se
            aplicável.
          </li>
          <li>
            <strong>Renderização no Player:</strong> O JavaScript do player
            (`player.js` ou `menu.js`) recebe o JSON da playlist e inicia a
            exibição das mídias em sequência, respeitando a duração e o layout
            definidos.
          </li>
        </ol>
      </section>

      <section id="logica-produtos">
        <h2>Fluxo: Sincronização de Produtos</h2>
        <p>
          Este processo assíncrono atualiza os preços e descrições dos produtos
          do menu digital, consultando um sistema externo (ERP).
        </p>
        <ol>
          <li>
            <strong>Gatilho:</strong> O administrador clica no botão
            "Sincronizar Preços" na página de produtos de uma loja.
          </li>
          <li>
            <strong>Enfileiramento do Job:</strong> A rota `POST
            /products/sync/:companyId` é chamada. O `product.controller.js` não
            executa a sincronização diretamente. Em vez disso, ele adiciona um
            novo job à fila do BullMQ com o nome `sync-single-company` e o
            `companyId` como dado.
            <pre><code>// product.controller.js
await productSyncQueue.add("sync-single-company", { companyId });</code></pre>
          </li>
          <li>
            <strong>Processamento pelo Worker:</strong> O serviço `worker`, que
            está rodando em um processo separado, está constantemente ouvindo a
            fila no Redis. Ele detecta o novo job e o executa.
          </li>
          <li>
            <strong>Execução da Lógica:</strong> O `productSync.service.js` é
            chamado pelo worker. Ele busca todos os produtos locais daquela
            empresa no banco do StreamBoard.
          </li>
          <li>
            <strong>Consulta ao ERP:</strong> Para cada produto local, ele
            extrai o código do produto e chama o `sysmo.service.js` para fazer
            uma consulta direta ao banco de dados do ERP Sysmo, buscando o preço
            e a descrição mais recentes.
          </li>
          <li>
            <strong>Atualização Local:</strong> Se encontrar dados atualizados,
            o serviço atualiza o registro correspondente no banco de dados do
            StreamBoard.
          </li>
          <li>
            <strong>Notificação:</strong> Ao final do processo, o
            `productSync.service.js` (ou o worker) pode emitir um evento via
            WebSocket para notificar o painel de administração que a
            sincronização foi concluída, permitindo que a interface do usuário
            seja atualizada em tempo real.
          </li>
        </ol>
      </section>

      <section id="logica-websockets">
        <h2>Fluxo: Comunicação Real-Time com WebSockets</h2>
        <p>
          A comunicação em tempo real é gerenciada pelo `websocket/manager.js` e
          é crucial para a interatividade do sistema.
        </p>
        <h4>Conexão</h4>
        <ul>
          <li>
            <strong>Dispositivos (Players):</strong> Ao iniciar, um player obtém
            um token JWT e se conecta ao endpoint WebSocket (`/`). O servidor o
            identifica pelo token e o armazena em um objeto `clients` usando seu
            ID como chave.
          </li>
          <li>
            <strong>Painel de Administração:</strong> Qualquer administrador
            logado no painel se conecta a um endpoint separado (`/admin-ws`). O
            servidor adiciona a conexão a um conjunto `adminClients`.
          </li>
        </ul>
        <h4>Disseminação de Informações</h4>
        <p>
          Quando uma ação importante ocorre, o servidor utiliza duas funções
          principais:
        </p>
        <ul>
          <li>
            <code>sendUpdateToDevice(deviceId, data)</code>: Envia uma mensagem
            específica para um único dispositivo. Usado para comandos remotos
            (reiniciar, atualizar playlist).
          </li>
          <li>
            <code>broadcastToAdmins(data)</code>: Envia uma mensagem para TODOS
            os administradores conectados. Usado para atualizar as tabelas e
            status em tempo real para todos os usuários do painel.
          </li>
        </ul>
        <p><strong>Exemplo de Fluxo:</strong></p>
        <ol>
          <li>
            Um dispositivo fica offline. Sua conexão WebSocket é encerrada.
          </li>
          <li>O evento `on('close')` no `websocket/manager.js` é disparado.</li>
          <li>O servidor remove o dispositivo da lista de clientes online.</li>
          <li>
            O servidor chama `broadcastToAdmins({ type: 'DEVICE_STATUS_UPDATE',
            ... })`.
          </li>
          <li>
            O `adminWs.js` em cada painel de administração aberto recebe a
            mensagem e atualiza o status do dispositivo na tabela da interface,
            mudando-o de "Online" para "Offline", sem precisar recarregar a
            página.
          </li>
        </ol>
      </section>

      <section id="backend-rotas">
        <h2>Rotas (Endpoints)</h2>
        <p>A seguir, uma lista das principais rotas da API e suas funções.</p>
        <table>
          <thead>
            <tr>
              <th>Método</th>
              <th>Endpoint</th>
              <th>Descrição</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><span class="tag tag-get">GET</span></td>
              <td><code>/devices</code></td>
              <td>Renderiza a página de listagem de dispositivos.</td>
            </tr>
            <tr>
              <td><span class="tag tag-post">POST</span></td>
              <td><code>/devices</code></td>
              <td>Cria um novo dispositivo.</td>
            </tr>
            <tr>
              <td><span class="tag tag-post">POST</span></td>
              <td><code>/devices/:id/edit</code></td>
              <td>Atualiza os dados de um dispositivo existente.</td>
            </tr>
            <tr>
              <td><span class="tag tag-post">POST</span></td>
              <td><code>/devices/:id/otp</code></td>
              <td>Gera um novo código OTP para pareamento.</td>
            </tr>
            <tr>
              <td><span class="tag tag-get">GET</span></td>
              <td><code>/api/device/playlist</code></td>
              <td>
                Endpoint protegido que os players usam para obter sua playlist
                de conteúdo.
              </td>
            </tr>
            <tr>
              <td><span class="tag tag-get">GET</span></td>
              <td><code>/campaigns</code></td>
              <td>Renderiza a página de listagem de campanhas.</td>
            </tr>
            <tr>
              <td><span class="tag tag-post">POST</span></td>
              <td><code>/campaigns</code></td>
              <td>
                Cria uma nova campanha, incluindo o upload de arquivos de mídia.
              </td>
            </tr>
            <tr>
              <td><span class="tag tag-post">POST</span></td>
              <td><code>/products/sync/:companyId</code></td>
              <td>
                Inicia um job de sincronização de produtos para uma empresa
                específica.
              </td>
            </tr>
          </tbody>
        </table>
      </section>

      <section id="backend-servicos">
        <h2>Serviços (Business Logic)</h2>
        <p>
          Os serviços encapsulam a lógica de negócio mais complexa e as
          interações com o banco de dados.
        </p>
        <h4>Exemplo: <code>campaign.service.js</code></h4>
        <p>
          Este serviço é responsável por toda a manipulação de dados de
          campanhas.
        </p>
        <ul>
          <li>
            <code>getAllCampaigns()</code>: Busca todas as campanhas com
            informações agregadas (nome da empresa, contagem de mídias) para a
            página de listagem.
          </li>
          <li>
            <code>createCampaign(data, files, ...)</code>: Executa uma transação
            no banco de dados para criar um registro de campanha, inserir os
            registros de upload de mídia e associar os alvos
            (dispositivos/setores), garantindo que tudo seja salvo ou nada seja
            salvo (atomicidade).
          </li>
          <li>
            <code>getAffectedDevicesForCampaign(campaignId)</code>: Uma função
            crucial que determina quais dispositivos serão impactados por uma
            mudança em uma campanha (criação, edição, exclusão), para que o
            servidor possa notificá-los via WebSocket.
          </li>
        </ul>
      </section>
    </main>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const sections = document.querySelectorAll("main section");
        const navLinks = document.querySelectorAll(".sidebar a");

        if (!sections.length || !navLinks.length) return;

        const observer = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting) {
                navLinks.forEach((link) => {
                  link.classList.remove("active");
                  if (link.getAttribute("href") === `#${entry.target.id}`) {
                    link.classList.add("active");
                  }
                });
              }
            });
          },
          { rootMargin: "-20% 0px -70% 0px", threshold: 0 }
        );

        sections.forEach((section) => observer.observe(section));
      });
    </script>
  </body>
</html>
